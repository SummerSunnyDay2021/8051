/*
 *	
 1	SCON --- 串口控制寄存器
 	7	6	5	4	3	2	1	0		---- 可位寻址，复位后置 0
 	SM0	SM1	SM2	REN	TB8	RB8	TI	RI

 		-- SM0/SM1 ，通讯模式，这里用 模式 1，也就是 SM0 = 0， SM1 = 1
		-- 多机通信控制位（基本不用）
		-- 使能串行接收。REN = 1 可以接收数据， REN = 0 单片机拒绝接受数据
		-- 模式2
		-- 模式2
		-- 发送中断标志位 TI， 当 TI = 1 表示发送电路发送到停止位的中间位置，由硬件置 1，进入中断后需要软件清 0
		-- 接受中断标志位 RI， 当 RI = 1 表示接收电路接收到停止位的中间位置，由硬件置 1，进入中断后需要软件清 0
		
		注意： 串口中断号为 4
		
 2	波特率发生器
		串口信号具体由定时器 1 或者 定时器 2 来产生（不能用定时器 0）
		需要将 定时器 设为自动重装模式
		定时器初值计算公式 TH1 = TL1 = 256 - 晶振值/12/2/16/波特率，如下：
			256 - 11059200/12/2/16/9600 = 256 - 11059200/12/32/9600 = 253 = 0xFF - 2 = 0xFD
		注意： 使用波特率发生器时，定时器不能用作其他用途，应当关闭定时器中断

		电源管理寄存器 PCON 的最高位置 1 时，即 PCON = PCON | 0x80，可将波特率翻倍，那么波特率的计算公式变为：
			TH1 = TL1 = 256 - 晶振值/12/16/波特率
		最后启动定时器即可， TR1 = 1；
		
 3	串口发送接受缓存寄存器 SBUF
 		SBUF 实际上是两个寄存器，但两个寄存器重名并且地址也一样，硬件根据程序是读数据还是写数据来区分两个寄存器的使用

 ---------------------------------------------------------
	实验结果：
	如果将波特率发生器 倍频，最高波特率为 28800
	不倍频的话 最高 14400，理论值应该为 19200，（由于没有逻辑分析仪，估计错误出现的原因为 晶振 精度问题）

	关于计算公式除不尽的问题， STC 手册里有相当详细的说明。
 ---------------------------------------------------------	
**/

#include<reg52.h>

unsigned char code uart_baud = 256 - 11059200/12/32/14400;

void uart_config(void);
void baud_config(void);

void main(void){
	uart_config();
	baud_config();
	while(1);
}

void uart_config(void){
//	PCON = PCON | 0x80;
	SCON = 0x50;
	ES = 1;		// 串口中断使能
}

void baud_config(void){
	TMOD = TMOD & 0x0F;		// 清零 高 8 位
	TMOD = TMOD | 0x20;		// 高 8 位设为 4'b0010 即自动重装模式
	EA = 1;
	IT1 = 0;				//关闭 定时器 1 中断
	TH1 = uart_baud;
	TL1 = uart_baud;
	TR1 = 1;
}

void uart_interrupt(void) interrupt 4 {
	if(TI)
		TI = 0;
	if(RI) {
		SBUF = SBUF + 1;
		RI = 0;
	}
}